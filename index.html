<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>hserus3</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f9fafb; color: #111; margin: 20px; }
    h1 { text-align: center; }
    button { padding: 8px 16px; margin: 10px 0; cursor: pointer; border: none; border-radius: 6px; background: #2563eb; color: #fff; }
    #status { margin: 10px 0; font-weight: bold; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { padding: 8px 12px; border: 1px solid #ddd; text-align: center; }
    th { background: #f3f4f6; cursor: pointer; }
    tr:nth-child(even) { background: #f9f9f9; }
    .green { color: green; font-weight: bold; }
    .red { color: red; font-weight: bold; }
  </style>
</head>
<body>
  <h1>hserus3</h1>
  <button onclick="refreshData()">Refresh</button>
  <div id="status">Idle</div>
  <table id="screener">
    <thead>
      <tr>
        <th onclick="sortTable(0)">Symbol</th>
        <th onclick="sortTable(1)">Current Close %</th>
        <th onclick="sortTable(2)">% More than Prev</th>
        <th onclick="sortTable(3)">Prev Candle</th>
        <th onclick="sortTable(4)">Volume % Chg</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    const API_KLINES = "https://fapi.binance.com/fapi/v1/klines";
    const API_EXCHANGEINFO = "https://fapi.binance.com/fapi/v1/exchangeInfo";
    const API_TICKER24H = "https://fapi.binance.com/fapi/v1/ticker/24hr";
    const excludeSymbols = ["BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT","ADAUSDT","DOGEUSDT","TRXUSDT","MATICUSDT","DOTUSDT","TONUSDT","LTCUSDT","BCHUSDT","AVAXUSDT","LINKUSDT","UNIUSDT","XLMUSDT","OPUSDT","ETCUSDT","NEARUSDT"];

    async function fetchSymbols() {
      let resInfo = await fetch(API_EXCHANGEINFO);
      let dataInfo = await resInfo.json();
      let symbolsAll = dataInfo.symbols.filter(s=>s.contractType==="PERPETUAL").map(s=>s.symbol);

      let resTick = await fetch(API_TICKER24H);
      let tickers = await resTick.json();

      let filtered = tickers.filter(t => symbolsAll.includes(t.symbol));
      filtered.sort((a,b)=> parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume));

      // Only USDT pairs, exclude USDC, exclude top 20
      let symbols = filtered.map(t=>t.symbol).filter(s=>
        s.endsWith("USDT") &&
        !s.endsWith("USDC") &&
        !excludeSymbols.includes(s)
      );

      return symbols.slice(0,200);
    }

    async function fetchKlines(symbol, interval="15m", limit=5) {
      let url = `${API_KLINES}?symbol=${symbol}&interval=${interval}&limit=${limit}`;
      let res = await fetch(url);
      return res.json();
    }

    async function checkSymbol(symbol) {
      try {
        let klines = await fetchKlines(symbol);
        if (!klines || klines.length < 3) return null;

        let last = klines.length-1;
        let prev = last-1;
        let prevprev = last-2;

        let openCurr = parseFloat(klines[last][1]);
        let closeCurr = parseFloat(klines[last][4]);
        let volCurr = parseFloat(klines[last][5]);

        let openPrev = parseFloat(klines[prev][1]);
        let closePrev = parseFloat(klines[prev][4]);
        let volPrev = parseFloat(klines[prev][5]);

        let openPrevPrev = parseFloat(klines[prevprev][1]);
        let closePrevPrev = parseFloat(klines[prevprev][4]);

        // Candle colour
        let currGreen = closeCurr > openCurr;
        if (!currGreen) return null; // Condition (1)

        let prevGreen = closePrev > openPrev ? "Green" : "Red";

        // Close % changes
        let currChg = ((closeCurr - openCurr) / openCurr) * 100;
        let prevChg = ((closePrev - openPrev) / openPrev) * 100;
        let prevPrevChg = ((closePrevPrev - openPrevPrev) / openPrevPrev) * 100;

        // Condition (2): curr > abs(prev & prevprev)
        if (!(currChg > Math.abs(prevChg) && currChg > Math.abs(prevPrevChg))) return null;

        // Extra metrics
        let moreThanPrev = prevChg !== 0 ? ((currChg / Math.abs(prevChg)) * 100).toFixed(1) + "%" : "âˆž";
        let volChg = ((volCurr - volPrev) / volPrev) * 100;

        return {
          symbol,
          currChg: currChg.toFixed(2)+"%",
          moreThanPrev,
          prevColor: prevGreen,
          volChg: volChg.toFixed(2)+"%"
        };
      } catch(e) {
        console.error(symbol, e);
        return null;
      }
    }

    async function refreshData() {
      document.querySelector("tbody").innerHTML = "<tr><td colspan='5'>Loading symbols...</td></tr>";
      document.getElementById("status").innerText = "Fetching top 200 symbols...";
      let symbols = await fetchSymbols();

      let results = [];
      for (let i=0;i<symbols.length;i++) {
        document.getElementById("status").innerText = `Scanning ${i+1}/${symbols.length}: ${symbols[i]}`;
        let row = await checkSymbol(symbols[i]);
        if (row) results.push(row);
      }

      let tbody = document.querySelector("tbody");
      tbody.innerHTML = "";
      if (results.length === 0) {
        tbody.innerHTML = "<tr><td colspan='5'>No matches found</td></tr>";
      } else {
        results.forEach(r=>{
          tbody.innerHTML += `<tr>
            <td>${r.symbol}</td>
            <td>${r.currChg}</td>
            <td>${r.moreThanPrev}</td>
            <td class="${r.prevColor==='Green'?'green':'red'}">${r.prevColor}</td>
            <td>${r.volChg}</td>
          </tr>`;
        });
      }
      document.getElementById("status").innerText = "Scan complete";
    }

    function sortTable(col) {
      let table = document.getElementById("screener");
      let rows = Array.from(table.rows).slice(1);
      let asc = table.getAttribute("data-sort-col")==col && table.getAttribute("data-sort-dir")=="asc" ? false : true;
      rows.sort((a,b)=>{
        let x = a.cells[col].innerText.replace("%","");
        let y = b.cells[col].innerText.replace("%","");
        if (isNaN(x) || isNaN(y)) return asc ? x.localeCompare(y) : y.localeCompare(x);
        return asc ? x-y : y-x;
      });
      rows.forEach(r=>table.tBodies[0].appendChild(r));
      table.setAttribute("data-sort-col", col);
      table.setAttribute("data-sort-dir", asc ? "asc":"desc");
    }

    // Run on page load
    refreshData();
  </script>
</body>
</html>

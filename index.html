<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>hserus3</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #0d1117;
      color: #e6edf3;
      margin: 0;
      padding: 20px;
    }
    h2 { text-align: center; margin-bottom: 20px; }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      border: 1px solid #30363d;
      padding: 6px 10px;
      text-align: right;
    }
    th {
      background: #161b22;
      position: sticky;
      top: 0;
    }
    tr:nth-child(even) { background: #161b22; }
    tr:hover { background: #21262d; }
    td.symbol { text-align: left; font-weight: bold; color: #58a6ff; }
    .positive { color: #3fb950; }
    .negative { color: #f85149; }
  </style>
</head>
<body>
  <h2>hserus3</h2>
  <table id="data-table">
    <thead>
      <tr>
        <th>Symbol</th>
        <th>Close %</th>
        <th>Vol %</th>
        <th>OI Î”</th>
        <th>Long Ratio</th>
        <th>New Longs</th>
        <th>New Shorts</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    async function getTop200Symbols() {
      try {
        // 1. Fetch exchange info to get all USDT perpetuals
        const exchangeInfo = await fetch("https://fapi.binance.com/fapi/v1/exchangeInfo").then(r => r.json());
        let usdtSymbols = exchangeInfo.symbols
          .filter(s => s.contractType === "PERPETUAL" && s.symbol.endsWith("USDT") && !s.symbol.includes("USDC"))
          .map(s => s.symbol);

        // 2. Fetch 24h stats
        const stats = await fetch("https://fapi.binance.com/fapi/v1/ticker/24hr").then(r => r.json());
        let statsMap = {};
        stats.forEach(s => { statsMap[s.symbol] = s; });

        // 3. Score each symbol
        let scored = usdtSymbols.map(sym => {
          let st = statsMap[sym];
          if (!st) return null;
          let vol = parseFloat(st.quoteVolume || 0);
          let pct = Math.abs(parseFloat(st.priceChangePercent || 0));
          return { symbol: sym, score: vol * pct };
        }).filter(x => x);

        // 4. Sort and take top 200
        scored.sort((a, b) => b.score - a.score);
        let top200 = scored.slice(0, 200).map(x => x.symbol);

        // 5. Exclude top 30 global market cap coins
        const excluded = [
          "BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT","ADAUSDT","DOGEUSDT",
          "AVAXUSDT","TRXUSDT","DOTUSDT","MATICUSDT","SHIBUSDT","LINKUSDT","BCHUSDT",
          "LTCUSDT","ICPUSDT","ETCUSDT","UNIUSDT","XLMUSDT","APTUSDT",
          "NEARUSDT","FILUSDT","HBARUSDT","VETUSDT","MNTUSDT","RNDRUSDT",
          "ARBUSDT","OPUSDT","AAVEUSDT","GRTUSDT"
        ];
        top200 = top200.filter(sym => !excluded.includes(sym));

        return top200;
      } catch (e) {
        console.error("Error fetching top200 symbols:", e);
        return [];
      }
    }

    // Storage for last values
    let lastData = {};

    async function fetchData() {
      const symbols = await getTop200Symbols();
      const tableBody = document.querySelector("#data-table tbody");
      tableBody.innerHTML = "";

      for (const symbol of symbols) {
        try {
          // Open Interest
          const oiData = await fetch(`https://fapi.binance.com/fapi/v1/openInterest?symbol=${symbol}`).then(r => r.json());
          let oi = parseFloat(oiData.openInterest);

          // Long/Short ratio
          const ratioData = await fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${symbol}&period=5m&limit=2`).then(r => r.json());
          let longRatio = ratioData.length > 0 ? parseFloat(ratioData[ratioData.length - 1].longAccount) * 100 : 50;

          // 24h stats for close% and volume%
          const ticker = await fetch(`https://fapi.binance.com/fapi/v1/ticker/24hr?symbol=${symbol}`).then(r => r.json());
          let closeChange = parseFloat(ticker.priceChangePercent || 0);
          let volChange = parseFloat(ticker.volume || 0);

          // Previous data
          let prev = lastData[symbol] || { oi: oi, longRatio: longRatio };

          // Changes
          let oiChange = oi - prev.oi;
          let ratioChange = longRatio - prev.longRatio;

          // Distribution
          let newLongs = (ratioChange / 100) * oi + (longRatio / 100) * oiChange;
          let newShorts = oiChange - newLongs;

          // Save
          lastData[symbol] = { oi, longRatio };

          // Row
          const row = document.createElement("tr");
          row.innerHTML = `
            <td class="symbol">${symbol}</td>
            <td class="${closeChange >= 0 ? "positive" : "negative"}">${closeChange.toFixed(2)}%</td>
            <td>${volChange.toFixed(2)}</td>
            <td class="${oiChange >= 0 ? "positive" : "negative"}">${oiChange.toFixed(2)}</td>
            <td>${longRatio.toFixed(2)}%</td>
            <td class="${newLongs >= 0 ? "positive" : "negative"}">${newLongs.toFixed(2)}</td>
            <td class="${newShorts >= 0 ? "positive" : "negative"}">${newShorts.toFixed(2)}</td>
          `;
          tableBody.appendChild(row);
        } catch (err) {
          console.error("Error for symbol", symbol, err);
        }
      }
    }

    // Refresh every 60s
    fetchData();
    setInterval(fetchData, 60000);
  </script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>hserus3</title>
<style>
:root{
  --bg:#071827; --card:#0b2430; --muted:#9fb6c7; --accent:#7be3c7; --danger:#ff6b6b;
  --text:#e6f3f6;
}
*{box-sizing:border-box}
body{
  margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:linear-gradient(#021119,#051521);
  color:var(--text);padding:18px;
}
header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
h1{margin:0;font-size:20px}
.controls{display:flex;gap:8px;align-items:center}
button{padding:8px 12px;border-radius:8px;border:none;background:var(--accent);color:#012;cursor:pointer}
button:disabled{opacity:0.5;cursor:not-allowed}
.small{font-size:13px;color:var(--muted)}
.tablewrap{margin-top:14px;overflow:auto;border-radius:8px}
table{width:100%;border-collapse:collapse;min-width:1000px}
th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,0.04);text-align:right}
th{background:rgba(255,255,255,0.02);cursor:pointer;color:var(--muted);position:sticky;top:0}
td.symbol{text-align:left;color:#7bdfff;font-weight:600}
.green{color:#7be3c7}
.red{color:var(--danger)}
.center{ text-align:center }
.placeholder{color:var(--muted)}
.progress{font-size:14px;color:var(--muted)}
@media(max-width:820px){ th,td{padding:6px;font-size:12px} }
</style>
</head>
<body>
  <header>
    <div>
      <h1>hserus3</h1>
      <div class="small">hserus3</div>
    </div>

    <div class="controls">
      <button id="refreshBtn">ðŸ”„ Refresh Data</button>
      <div id="status" class="small progress">Idle</div>
    </div>
  </header>

  <div class="tablewrap" aria-live="polite">
    <table id="resultsTable" role="table" aria-label="scanner results">
      <thead>
        <tr>
          <th data-key="symbol">Symbol</th>
          <th data-key="close_pct">Close % (1h)</th>
          <th data-key="vol_pct">Vol % (1h)</th>
          <th data-key="oi_delta">OI Î” (USD)</th>
          <th data-key="oi_delta_pct">OI Î” %</th>
          <th data-key="long_prev_pct">Long% prev</th>
          <th data-key="long_curr_pct">Long% curr</th>
          <th data-key="delta_longs_usd">Î” Longs (USD)</th>
          <th data-key="delta_shorts_usd">Î” Shorts (USD)</th>
        </tr>
      </thead>
      <tbody id="tbody">
        <tr><td colspan="9" class="placeholder">Click <strong>Refresh Data</strong> to start scan.</td></tr>
      </tbody>
    </table>
  </div>

<script>
/* ===== CONFIG ===== */
const BASE = 'https://fapi.binance.com';
const MAX_SYMBOLS = 200;
const PAUSE_MS = 120; // polite pause between requests
const EXCLUDE_TOP30 = new Set([
  "BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT","ADAUSDT","DOGEUSDT",
  "AVAXUSDT","TRXUSDT","DOTUSDT","MATICUSDT","SHIBUSDT","LINKUSDT","BCHUSDT",
  "LTCUSDT","ICPUSDT","ETCUSDT","UNIUSDT","XLMUSDT","APTUSDT","NEARUSDT",
  "FILUSDT","HBARUSDT","VETUSDT","RNDRUSDT","ARBUSDT","OPUSDT","AAVEUSDT","GRTUSDT","KLAYUSDT"
]);

/* ===== DOM ===== */
const refreshBtn = document.getElementById('refreshBtn');
const statusEl = document.getElementById('status');
const tbody = document.getElementById('tbody');
const table = document.getElementById('resultsTable');

let results = [];         // array of rows
let sortState = {key:null, dir:'desc'}; // keep last sort

/* ===== Helpers ===== */
const sleep = ms => new Promise(r => setTimeout(r, ms));
async function fetchJSON(url){
  const res = await fetch(url);
  if(!res.ok) throw new Error(`HTTP ${res.status} ${url}`);
  return res.json();
}
function isNumber(n){ return typeof n === 'number' && Number.isFinite(n); }
function safeNum(v){ const n = Number(v); return Number.isFinite(n) ? n : null; }
function fmtNum(v, d=2){ if(!isNumber(v)) return 'â€”'; return Number(v).toLocaleString(undefined, {maximumFractionDigits:d}); }
function fmtPct(v, d=2){ if(!isNumber(v)) return 'â€”'; return (v>=0?'+':'') + Number(v).toFixed(d) + '%'; }
function fmtUsd(v){ if(!isNumber(v)) return 'â€”'; return (v>=0?'+':'') + Number(v).toLocaleString(undefined,{maximumFractionDigits:2}); }

/* robust parser: try common keys for OI item and return USD notional if possible */
function parseOiItem(item){
  if(!item || typeof item !== 'object') return null;
  const tryKeys = ['sumOpenInterestValue','sumOpenInterest','sumOpenInterestUsd','sumOpenInterestValueUsd','openInterest'];
  for(const k of tryKeys){
    if(k in item){
      const n = safeNum(item[k]);
      if(isNumber(n)) return n;
    }
  }
  // fallback: find first numeric field (descending magnitude)
  let vals = Object.values(item).map(v=>safeNum(v)).filter(isNumber);
  if(vals.length===0) return null;
  // return largest magnitude numeric assuming that's USD-scale
  vals.sort((a,b)=>Math.abs(b)-Math.abs(a));
  return vals[0];
}

/* robust parser for long% from position/account endpoints */
function parseLongPct(item){
  if(!item || typeof item !== 'object') return null;
  // position-based common fields
  if('longPosition' in item && 'shortPosition' in item){
    const la = safeNum(item.longPosition), sa = safeNum(item.shortPosition);
    if(isNumber(la) && isNumber(sa) && (la+sa)!==0) return (la/(la+sa))*100;
  }
  // direct percent-like
  const keys = ['longShortRatio','longShortPercent','longPositionRatio','longPercent','longAccount','longPosition','longAccountPercent','longAccountPct','longAccountRatio'];
  for(const k of keys){
    if(k in item){
      const v = safeNum(item[k]);
      if(!isNumber(v)) continue;
      // some endpoints return ratio like 0.62 or percent 62
      if(v>0 && v<=1) return v*100;
      if(v>=1 && v<=100) return v;
      // if it's bigger than 100, skip
    }
  }
  // account-based keys
  if('longAccount' in item && 'shortAccount' in item){
    const la = safeNum(item.longAccount), sa = safeNum(item.shortAccount);
    if(isNumber(la) && isNumber(sa) && (la+sa)!==0) return (la/(la+sa))*100;
  }
  // fallback: scan any numeric and if value in 0..100 return it
  for(const k in item){
    const v = safeNum(item[k]);
    if(isNumber(v) && v>=0 && v<=100) return v;
    if(isNumber(v) && v>0 && v<=1) return v*100;
  }
  return null;
}

/* ===== Step 1: symbol selection (top 200 volatile USDT perpetuals) ===== */
async function getTopSymbols(limit=MAX_SYMBOLS){
  statusEl.textContent = 'Fetching exchange info & 24h tickers...';
  const [exchangeInfo, tickers] = await Promise.all([
    fetchJSON(`${BASE}/fapi/v1/exchangeInfo`),
    fetchJSON(`${BASE}/fapi/v1/ticker/24hr`)
  ]);
  const perpSet = new Set(
    (exchangeInfo.symbols || [])
      .filter(s => s.contractType === 'PERPETUAL' && s.symbol.endsWith('USDT'))
      .map(s=>s.symbol)
  );
  const tickerMap = tickers || [];
  // compute score = quoteVolume * abs(priceChangePercent)
  const scored = tickerMap
    .filter(t => perpSet.has(t.symbol) && t.symbol.endsWith('USDT'))
    .map(t => {
      const quoteVol = safeNum(t.quoteVolume) || 0;
      const pct = Math.abs(safeNum(t.priceChangePercent) || 0);
      return { symbol: t.symbol, score: quoteVol * pct };
    })
    .sort((a,b)=>b.score - a.score)
    .map(x=>x.symbol);
  // take top N and exclude top30 caps
  let top = scored.filter(s => !EXCLUDE_TOP30.has(s)).slice(0, limit);
  return top;
}

/* ===== per-symbol fetchers ===== */
async function fetchKlines1h(symbol){
  const url = `${BASE}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=1h&limit=2`;
  return fetchJSON(url);
}
async function fetchOIHist(symbol){
  const url = `${BASE}/futures/data/openInterestHist?symbol=${encodeURIComponent(symbol)}&period=1h&limit=2`;
  return fetchJSON(url);
}
async function fetchLSPosition(symbol){
  // try position-based first
  let url = `${BASE}/futures/data/topLongShortPositionRatio?symbol=${encodeURIComponent(symbol)}&period=1h&limit=2`;
  try {
    const res = await fetchJSON(url);
    if(Array.isArray(res) && res.length>0) return res;
  } catch(e){
    // ignore and try account-based below
  }
  // fallback to account-based
  url = `${BASE}/futures/data/topLongShortAccountRatio?symbol=${encodeURIComponent(symbol)}&period=1h&limit=2`;
  try {
    const res2 = await fetchJSON(url);
    if(Array.isArray(res2) && res2.length>0) return res2;
  } catch(e){
    return null;
  }
  return null;
}

/* ===== main symbol processing logic ===== */
async function processSymbol(symbol, idx, total){
  try{
    statusEl.textContent = `Scanning ${idx} / ${total}: ${symbol}`;

    // 1h klines for close% and vol%
    let kl = null;
    try { kl = await fetchKlines1h(symbol); } catch(e){ kl = null; }
    let closePct = null, volPct = null;
    if(Array.isArray(kl) && kl.length >= 2){
      const prev = kl[kl.length-2], curr = kl[kl.length-1];
      const prevClose = safeNum(prev[4]), currClose = safeNum(curr[4]);
      const prevVol = safeNum(prev[5]), currVol = safeNum(curr[5]);
      if(isNumber(prevClose) && isNumber(currClose) && prevClose !== 0) closePct = ((currClose - prevClose)/prevClose)*100;
      if(isNumber(prevVol) && isNumber(currVol) && prevVol !== 0) volPct = ((currVol - prevVol)/prevVol)*100;
    }

    // open interest hist
    let oiHist = null;
    try { oiHist = await fetchOIHist(symbol); } catch(e){ oiHist = null; }
    let oiPrev = null, oiCurr = null, oiDelta = null, oiDeltaPct = null;
    if(Array.isArray(oiHist) && oiHist.length >= 2){
      oiPrev = parseOiItem(oiHist[0]);
      oiCurr = parseOiItem(oiHist[1]);
      if(isNumber(oiPrev) && isNumber(oiCurr)){
        oiDelta = oiCurr - oiPrev;
        oiDeltaPct = oiPrev !== 0 ? ((oiCurr - oiPrev)/oiPrev)*100 : null;
      }
    }

    // long/short position ratio (position based with fallback)
    let ls = null;
    try { ls = await fetchLSPosition(symbol); } catch(e){ ls = null; }
    let longPrevPct = null, longCurrPct = null;
    if(Array.isArray(ls) && ls.length >= 2){
      longPrevPct = parseLongPct(ls[0]);
      longCurrPct = parseLongPct(ls[1]);
    }

    // calculate delta longs/shorts USD using absolute OI allocations
    let deltaLongsUsd = null, deltaShortsUsd = null;
    if(isNumber(oiPrev) && isNumber(oiCurr) && isNumber(longPrevPct) && isNumber(longCurrPct)){
      const lpPrev = longPrevPct/100.0;
      const lpCurr = longCurrPct/100.0;
      const longOiPrev = lpPrev * oiPrev;
      const longOiCurr = lpCurr * oiCurr;
      const shortOiPrev = (1 - lpPrev) * oiPrev;
      const shortOiCurr = (1 - lpCurr) * oiCurr;
      deltaLongsUsd = longOiCurr - longOiPrev;
      deltaShortsUsd = shortOiCurr - shortOiPrev;
    }

    // push result (use 0 for missing numeric results so table shows zeros not NaN)
    const row = {
      symbol,
      close_pct: isNumber(closePct) ? closePct : null,
      vol_pct: isNumber(volPct) ? volPct : null,
      oi_delta: isNumber(oiDelta) ? oiDelta : null,
      oi_delta_pct: isNumber(oiDeltaPct) ? oiDeltaPct : null,
      long_prev_pct: isNumber(longPrevPct) ? longPrevPct : null,
      long_curr_pct: isNumber(longCurrPct) ? longCurrPct : null,
      delta_longs_usd: isNumber(deltaLongsUsd) ? deltaLongsUsd : null,
      delta_shorts_usd: isNumber(deltaShortsUsd) ? deltaShortsUsd : null
    };
    results.push(row);
    appendRow(row);
  } catch (e) {
    console.error('symbol error', symbol, e);
  } finally {
    // polite pause
    await sleep(PAUSE_MS);
  }
}

/* append single row (live) */
function appendRow(obj){
  const tr = document.createElement('tr');
  tr.innerHTML = `
    <td class="symbol">${obj.symbol}</td>
    <td class="${obj.close_pct>=0?'green':'red'}">${fmtPct(obj.close_pct)}</td>
    <td class="${obj.vol_pct>=0?'green':'red'}">${fmtPct(obj.vol_pct)}</td>
    <td class="${obj.oi_delta>=0?'green':'red'}">${isNumber(obj.oi_delta)?fmtNum(obj.oi_delta,2):'â€”'}</td>
    <td>${isNumber(obj.long_prev_pct)?fmtNum(obj.long_prev_pct,2)+'%':'â€”'}</td>
    <td>${isNumber(obj.long_curr_pct)?fmtNum(obj.long_curr_pct,2)+'%':'â€”'}</td>
    <td class="${obj.delta_longs_usd>=0?'green':'red'}">${isNumber(obj.delta_longs_usd)?fmtUsd(obj.delta_longs_usd):'â€”'}</td>
    <td class="${obj.delta_shorts_usd>=0?'green':'red'}">${isNumber(obj.delta_shorts_usd)?fmtUsd(obj.delta_shorts_usd):'â€”'}</td>
  `;
  tbody.appendChild(tr);
}

/* render full table from results (used after sorting) */
function renderFull(){
  if(!results || results.length===0){
    tbody.innerHTML = `<tr><td colspan="9" class="placeholder">No rows</td></tr>`;
    return;
  }
  tbody.innerHTML = '';
  for(const r of results) appendRow(r);
}

/* sorting â€” header click toggles asc/desc */
document.querySelectorAll('#resultsTable thead th').forEach((th, idx) => {
  th.addEventListener('click', () => {
    const key = th.getAttribute('data-key');
    if(!key) return;
    // toggle dir if same key
    if(sortState.key === key) sortState.dir = sortState.dir === 'asc' ? 'desc' : 'asc';
    else { sortState.key = key; sortState.dir = 'desc'; }
    results.sort((a,b) => {
      const va = a[key]; const vb = b[key];
      // handle nulls
      if(va === null || va === undefined) return 1;
      if(vb === null || vb === undefined) return -1;
      // symbol: string sort
      if(key === 'symbol') return sortState.dir === 'asc' ? vb.localeCompare(va) : va.localeCompare(vb);
      // numeric sort
      return sortState.dir === 'asc' ? (vb - va) : (va - vb);
    });
    renderFull();
  });
});

/* ===== main scan action ===== */
async function startScan(){
  try {
    refreshBtn.disabled = true;
    results = [];
    tbody.innerHTML = `<tr><td colspan="9" class="placeholder">Preparing scan...</td></tr>`;
    statusEl.textContent = 'Preparing symbol list...';

    const symbols = await getTopSymbols(MAX_SYMBOLS);
    if(!Array.isArray(symbols) || symbols.length===0){
      tbody.innerHTML = `<tr><td colspan="9" class="placeholder">No symbols found.</td></tr>`;
      statusEl.textContent = 'No symbols';
      refreshBtn.disabled = false;
      return;
    }

    tbody.innerHTML = '';
    const total = symbols.length;
    for(let i=0;i<total;i++){
      const sym = symbols[i];
      await processSymbol(sym, i+1, total);
      statusEl.textContent = `Scanning ${i+1} / ${total}: ${sym}`;
    }

    statusEl.textContent = `Scan complete â€” ${results.length} rows.`;
    refreshBtn.disabled = false;
  } catch (err){
    console.error(err);
    statusEl.textContent = 'Error: ' + (err.message || err);
    refreshBtn.disabled = false;
  }
}

/* wire refresh button */
refreshBtn.addEventListener('click', () => {
  // clear previous
  results = [];
  tbody.innerHTML = `<tr><td colspan="9" class="placeholder">Starting scan...</td></tr>`;
  startScan();
});

/* start on load? comment out if you don't want auto-start */
window.addEventListener('load', () => {
  // do not auto-start; require user press Refresh to begin
  // startScan();
});
</script>
</body>
</html>
